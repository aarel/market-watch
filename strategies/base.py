"""
Base strategy interface for trading strategies.

All trading strategies must inherit from the Strategy base class
and implement the required methods.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional

import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class TradingSignal:
    """
    Signal generated by a strategy.

    Attributes:
        symbol: Ticker symbol
        action: Buy, sell, or hold
        strength: Signal strength from 0.0 to 1.0 (for position sizing)
        reason: Human-readable explanation for the signal
        current_price: Current market price
        metadata: Strategy-specific additional data
    """
    symbol: str
    action: SignalType
    strength: float
    reason: str
    current_price: float
    metadata: dict = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

        # Ensure action is SignalType enum
        if isinstance(self.action, str):
            self.action = SignalType(self.action)

    @property
    def is_buy(self) -> bool:
        return self.action == SignalType.BUY

    @property
    def is_sell(self) -> bool:
        return self.action == SignalType.SELL

    @property
    def is_hold(self) -> bool:
        return self.action == SignalType.HOLD


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.

    Strategies analyze market data and generate trading signals.
    They should be stateless and deterministic - same inputs always
    produce same outputs.
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """
        Human-readable strategy name.

        Example: "Momentum Strategy"
        """
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """
        Brief description of the strategy logic.

        Example: "Buys stocks with strong upward momentum"
        """
        pass

    @property
    @abstractmethod
    def required_history(self) -> int:
        """
        Number of historical bars needed to generate signals.

        The strategy will not be called until at least this many
        bars are available.

        Example: 20 (for 20-day momentum calculation)
        """
        pass

    @abstractmethod
    def analyze(
        self,
        symbol: str,
        bars: pd.DataFrame,
        current_price: float,
        current_position: Optional[dict] = None
    ) -> TradingSignal:
        """
        Analyze a symbol and generate a trading signal.

        Args:
            symbol: Ticker symbol to analyze
            bars: Historical OHLCV data (most recent bar last)
                  Columns: open, high, low, close, volume
            current_price: Current market price
            current_position: Current position info or None
                             If provided, includes:
                             - quantity: Number of shares
                             - entry_price: Average entry price
                             - market_value: Current market value
                             - unrealized_pnl: Unrealized P&L
                             - unrealized_pnl_pct: Unrealized P&L %

        Returns:
            TradingSignal with recommendation
        """
        pass

    def configure(self, **params):
        """
        Update strategy parameters dynamically.

        Override this method if your strategy has configurable parameters.

        Args:
            **params: Parameter name-value pairs

        Example:
            strategy.configure(lookback_days=30, threshold=0.05)
        """
        for key, value in params.items():
            if hasattr(self, key):
                setattr(self, key, value)
            else:
                raise ValueError(f"Unknown parameter: {key}")

    def get_parameters(self) -> dict:
        """
        Get current strategy parameters.

        Override this to expose configurable parameters.

        Returns:
            Dictionary of parameter names and values
        """
        return {}

    def __str__(self) -> str:
        return f"{self.name}: {self.description}"

    def __repr__(self) -> str:
        params = self.get_parameters()
        param_str = ", ".join(f"{k}={v}" for k, v in params.items())
        return f"{self.__class__.__name__}({param_str})"
